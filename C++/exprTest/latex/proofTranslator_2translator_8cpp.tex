\hypertarget{proofTranslator_2translator_8cpp}{}\section{proof\+Translator/translator.cpp File Reference}
\label{proofTranslator_2translator_8cpp}\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
Include dependency graph for translator.\+cpp\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=224pt]{proofTranslator_2translator_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_a2f7913270ab9e4dbcc0bf9412ea26f0b}{read\+Formula}} (istream \&instrm, string \&str)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_a0604e7459787c8f3387008a1e5a41c24}{parse\+Formula}} (ofstream \&fout, const string \&str, int start, int stop)
\item 
bool \mbox{\hyperlink{proofTranslator_2translator_8cpp_ab5f4eef1e3fc90a71b6241fcf4fb6024}{is\+Last\+Formula}} ()
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_aaf8fc732865f459a3cee6fa7d4c4375f}{match\+End\+Parens}} (const string \&str, int start)
\item 
void \mbox{\hyperlink{proofTranslator_2translator_8cpp_ad27b55e5788fde384fbc0edc063934e0}{here\+Doc\+Preamble}} (ofstream \&fout)
\item 
void \mbox{\hyperlink{proofTranslator_2translator_8cpp_a98ce518ad3ac0466f0e17edb45d25e62}{remove\+White\+Space}} (string \&str)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_af39eee8557efea6ff599ac6cc72c3b23}{is\+Variable}} (const string \&str)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_a972ff985f6e91b57ec446f163780ea87}{is\+Conditional}} (const string \&)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_a7ddedf1549ca30c29da0ec84f483ccc5}{is\+And}} (const string \&)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_ac92f080c31a237e569ea813b14f61696}{is\+Or}} (const string \&)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_a32aef3652dc642a7f07782dcc4643802}{is\+Not}} (const string \&)
\item 
void \mbox{\hyperlink{proofTranslator_2translator_8cpp_a889f06c5a06aeb9561d4eb653940a995}{twoplaceemit}} (ofstream \&fout, const string \&str, int start, int oploc, const string \&op)
\item 
void \mbox{\hyperlink{proofTranslator_2translator_8cpp_aa438b6e9ea8a924375884fa9eda28c2a}{oneplaceemit}} (ofstream \&fout, const string \&str, int start, int oploc, const string \&op)
\item 
int \mbox{\hyperlink{proofTranslator_2translator_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}} ()
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_ad27b55e5788fde384fbc0edc063934e0}\label{proofTranslator_2translator_8cpp_ad27b55e5788fde384fbc0edc063934e0}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!here\+Doc\+Preamble@{here\+Doc\+Preamble}}
\index{here\+Doc\+Preamble@{here\+Doc\+Preamble}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{here\+Doc\+Preamble()}{hereDocPreamble()}}
{\footnotesize\ttfamily void here\+Doc\+Preamble (\begin{DoxyParamCaption}\item[{ofstream \&}]{fout }\end{DoxyParamCaption})}

emit the heredoc preamble code to a file 
\begin{DoxyParams}{Parameters}
{\em fout} & the ofstream to output to \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a7ddedf1549ca30c29da0ec84f483ccc5}\label{proofTranslator_2translator_8cpp_a7ddedf1549ca30c29da0ec84f483ccc5}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!is\+And@{is\+And}}
\index{is\+And@{is\+And}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{is\+And()}{isAnd()}}
{\footnotesize\ttfamily int is\+And (\begin{DoxyParamCaption}\item[{const string \&}]{str }\end{DoxyParamCaption})}

check if the given string is an and 
\begin{DoxyParams}{Parameters}
{\em str} & the string to be analyzed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the input string is an and returns -\/1 if not 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a972ff985f6e91b57ec446f163780ea87}\label{proofTranslator_2translator_8cpp_a972ff985f6e91b57ec446f163780ea87}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!is\+Conditional@{is\+Conditional}}
\index{is\+Conditional@{is\+Conditional}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{is\+Conditional()}{isConditional()}}
{\footnotesize\ttfamily int is\+Conditional (\begin{DoxyParamCaption}\item[{const string \&}]{str }\end{DoxyParamCaption})}

check if the given string is a conditional 
\begin{DoxyParams}{Parameters}
{\em str} & the string to be analyzed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the input string is a conditional and -\/1 if not 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_ab5f4eef1e3fc90a71b6241fcf4fb6024}\label{proofTranslator_2translator_8cpp_ab5f4eef1e3fc90a71b6241fcf4fb6024}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!is\+Last\+Formula@{is\+Last\+Formula}}
\index{is\+Last\+Formula@{is\+Last\+Formula}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{is\+Last\+Formula()}{isLastFormula()}}
{\footnotesize\ttfamily bool is\+Last\+Formula (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

ask the user if the previously entered formula was the last \begin{DoxyReturn}{Returns}
true if the user choose so returns false if not 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a32aef3652dc642a7f07782dcc4643802}\label{proofTranslator_2translator_8cpp_a32aef3652dc642a7f07782dcc4643802}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!is\+Not@{is\+Not}}
\index{is\+Not@{is\+Not}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{is\+Not()}{isNot()}}
{\footnotesize\ttfamily int is\+Not (\begin{DoxyParamCaption}\item[{const string \&}]{str }\end{DoxyParamCaption})}

check if the given string is a not 
\begin{DoxyParams}{Parameters}
{\em str} & the string to be analyzed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the input string is a not and -\/1 if not 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_ac92f080c31a237e569ea813b14f61696}\label{proofTranslator_2translator_8cpp_ac92f080c31a237e569ea813b14f61696}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!is\+Or@{is\+Or}}
\index{is\+Or@{is\+Or}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{is\+Or()}{isOr()}}
{\footnotesize\ttfamily int is\+Or (\begin{DoxyParamCaption}\item[{const string \&}]{str }\end{DoxyParamCaption})}

check if the given string is an or 
\begin{DoxyParams}{Parameters}
{\em str} & the string to be analyzed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the input string is an or returns -\/1 if not 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_af39eee8557efea6ff599ac6cc72c3b23}\label{proofTranslator_2translator_8cpp_af39eee8557efea6ff599ac6cc72c3b23}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!is\+Variable@{is\+Variable}}
\index{is\+Variable@{is\+Variable}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{is\+Variable()}{isVariable()}}
{\footnotesize\ttfamily int is\+Variable (\begin{DoxyParamCaption}\item[{const string \&}]{str }\end{DoxyParamCaption})}

check if the given string is a single propostional variable 
\begin{DoxyParams}{Parameters}
{\em str} & the string to be analyzed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the input string is a variable and -\/1 if not 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}\label{proofTranslator_2translator_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!main@{main}}
\index{main@{main}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{proofTranslator_2translator_8cpp_aaf8fc732865f459a3cee6fa7d4c4375f}\label{proofTranslator_2translator_8cpp_aaf8fc732865f459a3cee6fa7d4c4375f}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!match\+End\+Parens@{match\+End\+Parens}}
\index{match\+End\+Parens@{match\+End\+Parens}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{match\+End\+Parens()}{matchEndParens()}}
{\footnotesize\ttfamily int match\+End\+Parens (\begin{DoxyParamCaption}\item[{const string \&}]{str,  }\item[{int}]{start }\end{DoxyParamCaption})}

given a string and the index of an open paren return the index of it\textquotesingle{}s matching paren 
\begin{DoxyParams}{Parameters}
{\em str} & the string being analyzed \\
\hline
{\em start} & the opening paren to be matched \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the index of the required closing paren or -\/1 if it cannot find a closing paren 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_aa438b6e9ea8a924375884fa9eda28c2a}\label{proofTranslator_2translator_8cpp_aa438b6e9ea8a924375884fa9eda28c2a}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!oneplaceemit@{oneplaceemit}}
\index{oneplaceemit@{oneplaceemit}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{oneplaceemit()}{oneplaceemit()}}
{\footnotesize\ttfamily void oneplaceemit (\begin{DoxyParamCaption}\item[{ofstream \&}]{fout,  }\item[{const string \&}]{str,  }\item[{int}]{start,  }\item[{int}]{oploc,  }\item[{const string \&}]{op }\end{DoxyParamCaption})}

emit the correct character sequence for a one character operator 
\begin{DoxyParams}{Parameters}
{\em fout} & the stream to output to \\
\hline
{\em str} & the string being analyzed \\
\hline
{\em start} & the starting point in the string to work on \\
\hline
{\em oploc} & the location of the operator in the expression \\
\hline
{\em op} & the operator that will be emitted \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a0604e7459787c8f3387008a1e5a41c24}\label{proofTranslator_2translator_8cpp_a0604e7459787c8f3387008a1e5a41c24}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!parse\+Formula@{parse\+Formula}}
\index{parse\+Formula@{parse\+Formula}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{parse\+Formula()}{parseFormula()}}
{\footnotesize\ttfamily int parse\+Formula (\begin{DoxyParamCaption}\item[{ofstream \&}]{fout,  }\item[{const string \&}]{str,  }\item[{int}]{start,  }\item[{int}]{stop }\end{DoxyParamCaption})}

recursively parse a formula and emit the correct sequence of characters to a file 
\begin{DoxyParams}{Parameters}
{\em fout} & the file stream to emit to \\
\hline
{\em the} & string to parse \\
\hline
{\em the} & start position in the string to parse from (possibly unnecessary) \\
\hline
{\em the} & ending position in the string to parse from (possibly unnecessary) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
currently returns 1 always but may return something more useful in the future 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a2f7913270ab9e4dbcc0bf9412ea26f0b}\label{proofTranslator_2translator_8cpp_a2f7913270ab9e4dbcc0bf9412ea26f0b}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!read\+Formula@{read\+Formula}}
\index{read\+Formula@{read\+Formula}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{read\+Formula()}{readFormula()}}
{\footnotesize\ttfamily int read\+Formula (\begin{DoxyParamCaption}\item[{istream \&}]{instrm,  }\item[{string \&}]{str }\end{DoxyParamCaption})}

read a formula from the user into a string 
\begin{DoxyParams}{Parameters}
{\em the} & input stream to read from (probably not necessary) \\
\hline
{\em the} & string to read into \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
currently returns 0 always but may return something more useful in the future 
\end{DoxyReturn}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a98ce518ad3ac0466f0e17edb45d25e62}\label{proofTranslator_2translator_8cpp_a98ce518ad3ac0466f0e17edb45d25e62}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!remove\+White\+Space@{remove\+White\+Space}}
\index{remove\+White\+Space@{remove\+White\+Space}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{remove\+White\+Space()}{removeWhiteSpace()}}
{\footnotesize\ttfamily void remove\+White\+Space (\begin{DoxyParamCaption}\item[{string \&}]{str }\end{DoxyParamCaption})}

remove space characters from the input string 
\begin{DoxyParams}{Parameters}
{\em str} & the string having whitespace removed \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{proofTranslator_2translator_8cpp_a889f06c5a06aeb9561d4eb653940a995}\label{proofTranslator_2translator_8cpp_a889f06c5a06aeb9561d4eb653940a995}} 
\index{proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}!twoplaceemit@{twoplaceemit}}
\index{twoplaceemit@{twoplaceemit}!proof\+Translator/translator.\+cpp@{proof\+Translator/translator.\+cpp}}
\subsubsection{\texorpdfstring{twoplaceemit()}{twoplaceemit()}}
{\footnotesize\ttfamily void twoplaceemit (\begin{DoxyParamCaption}\item[{ofstream \&}]{fout,  }\item[{const string \&}]{str,  }\item[{int}]{start,  }\item[{int}]{oploc,  }\item[{const string \&}]{op }\end{DoxyParamCaption})}

emit the correct character sequence for a two character operator 
\begin{DoxyParams}{Parameters}
{\em fout} & the stream to output to \\
\hline
{\em str} & the string being analyzed \\
\hline
{\em start} & the starting point in the string to work on \\
\hline
{\em oploc} & the location of the first character of the operator in the expression \\
\hline
{\em op} & the operator that will be emitted \\
\hline
\end{DoxyParams}
